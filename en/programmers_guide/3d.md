<div class="langs">
  <a href="#" class="btn" onclick="toggleLanguage()">中文</a>
</div>

# 3D

You probably started with Cocos2d-x and know it as a 2D game engine. Starting
with version 3, 3D features are being added and refined. 3D gaming is a huge
market and Cocos2d-x is adding all the features you need for 3D development. 3D
development might be new to you and use some terminology that you are unfamiliar
with. There are also additional software tools that you need to become familiar
with. Let's jump right in and get our feet wet.

<a name="about"></a>

## Terminology
When using 3D, there are some commonly used terms that you should be familiar with:

* __Mesh__ - vertices that construct a shape and texture with which you are
rendering.

* __Model__ - an object that can be rendered. It is a collection of meshes. In our
engine `Sprite3D`.

* __Texture__ - All surfaces and vertices of a 3D model can be mapped to a texture.
In most cases you will have multiple textures per model, unwrapped in a texture
atlas.

* __Camera__ - Since a 3D world is not flat, you need to set a camera to look at
it. You get different scenes with different camera parameters.

* __Light__ - Lightening is applied to make scenes look realistic. To make an object
look real, the color should change according to the light. When you face the light
it is bright and the opposite is dark. _Lightening_ an object means computing the
object's color according to the light.

<a name="sprite3d"></a>

## Sprite3D
Just like 2D games, 3D games also have `Sprite` objects. `Sprite` objects are a
core foundation of any game. One of the main differences between `Sprite` and
`Sprite3D` is `Sprite3D` objects have 3 axes it can be positioned on:
__x__,  __y__ and __z__. `Sprite3D` works in many ways just like a normal `Sprite`.
It is easy to load and display a `Sprite3D` object:

{% codetabs name="C++", type="cpp" -%}
auto sprite = Sprite3D::create("boss.c3b"); //c3b file, created with the FBX-converter
sprite->setScale(5.f); //sets the object scale in float
sprite->setPosition(Vec2(200,200)); //sets sprite position
scene->addChild(sprite,1); //adds sprite to scene, z-index: 1
{%- endcodetabs %}

This creates and positions a `Sprite3D` object from `.c3b` file. Example:

![](3d-img/9_1.png)

Now, let's rotate the model in a loop. For this we will create an action and run
it:

{% codetabs name="C++", type="cpp" -%}
//rotate around the X axis
auto rotation = RotateBy::create(15, Vec3(0, 360, 0));
//our sprite object runs the action
sprite->runAction(RepeatForever::create(rotation));
{%- endcodetabs %}

To set an anchor point on the `Sprite` or `Sprite3D` use:

{% codetabs name="C++", type="cpp" -%}
sprite->setAnchorPoint(Point(0.0f,0.0f));
{%- endcodetabs %}

<a name="models"></a>

### Attaching 3D models to Sprite3D objects.
Recall above that a 3D model is a collection of __meshes__. You can attach 3D models
to other 3D models to create rich effects. An example would
be adding a weapon to a character. To do this you need to find the attachment
point where the weapon is to be added. For this use the __getAttachNode(attachment_point_name)__
function. And then we just add the new model to the attachment point as a child
with __addChild()__. You can think of this as combining multiple simpler 3D models
to create more complex models. For example adding a model to a `Sprite3D` object:

{% codetabs name="C++", type="cpp" -%}
auto sp = Sprite3D::create("axe.c3b");
sprite->getAttachNode("Bip001 R Hand")->addChild(sp);
{%- endcodetabs %}

![](3d-img/9_3.png)

### Swap 3D Model
When doing 3D development you might want to make dynamic changes to your model.
Perhaps due to power-ups, costume changes or visual cues to notify the user about
status changes of your model. If your 3D model is comprised from __meshes__ you can
access the __mesh data__ using __getMeshByIndex()__ and __getMeshByName()__. Using
these functions it is possible to achieve effects like swapping a weapon or clothing
for a character. Let's take a look at an example of a girl wearing a coat:

![](3d-img/9_4.png)

We can change the coat that the girl is wearing by changing the visibility of
the __mesh__ objects we are using. The following example demonstrates how to do
this:

{% codetabs name="C++", type="cpp" -%}
auto sprite = Sprite3D::create("ReskinGirl.c3b");

// display the first coat
auto girlTop0 = sprite->getMeshByName("Girl_UpperBody01");
girlTop0->setVisible(true);

auto girlTop1 = sprite->getMeshByName("Girl_UpperBody02");
girlTop1->setVisible(false);

// swap to the second coat
girlTop0->setVisible(false);
girlTop1->setVisible(true);
{%- endcodetabs %}

The results:

![](3d-img/9_4_0.png)

<a name="animations"></a>

##Animation
`Sprite3D` objects are essential to our game! We have learned how to manipulate them.
However, we might want a more rich experience. Enter animation! To run a 3d
animation, you can use the `Animation3D` and `Animate3D` objects. You then create
an `Animate3D` action using the `Animation3D` object. Example:

{% codetabs name="C++", type="cpp" -%}
// the animation is contained in the .c3b file
auto animation = Animation3D::create("orc.c3b");

// creates the Action with Animation object
auto animate = Animate3D::create(animation);

// runs the animation
sprite->runAction(RepeatForever::create(animate));
{%- endcodetabs %}

Run the example __Programmer Guide Sample__ code to see this in action! Please
keep in mind that 3D animations are exactly the same concepts as 2D. Please refer
to Chapter 4 in this guide.

###Multiple animations
What do you do when you want to run multiple __animations__ at the same time?
Using both the __animation start time__ and __animation length__ parameters you
can create multiple animations. The unit for both parameters is seconds. Example:

{% codetabs name="C++", type="cpp" -%}
auto animation = Animation3D::create(fileName);

auto runAnimate = Animate3D::create(animation, 0, 2);
sprite->runAction(runAnimate);

auto attackAnimate = Animate3D::create(animation, 3, 5);
sprite->runAction(attackAnimate);
{%- endcodetabs %}

In the above example there are two animations that get run. The first starts
immediately and lasts for *2 seconds*. The second starts after *3 seconds* and lasts
for *5 seconds*.

###Animation speed
The __speed__ of the animation is a positive integer for forward while
a negative speed would be reverse. In this case the speed is set to *10*.
This means that this animation can be considered to be *10* seconds in length.

###Animation blending
When using multiple animations, __blending__ is automatically applied between each
animation. The purpose of __blending__ is to create a smooth transition between
effects. Given two animations, A and B, the last few frames of animation A and
the first few frames of animation B overlap to make the change in animation look
natural.

The default transition time is 0.1 seconds. You can set the transition time by
using __Animate3D::setTransitionTime__.

Cocos2d-x only supports __linear interpolation__ between keyframes. This fills in
__gaps__ in the curve to ensure a smooth path. If you use other interpolation
methods in the model production, our built-in tool, __fbx-conv__ will
generate additional keyframes to compensate. This compensation is completed in
accordance with the target frame. For more information on __fbx-conv__ please refer
to the section discussing it at the end of this chapter.

<a name="camera"></a>

##Camera
__Camera__ objects are an important aspect of 3D development. Since a 3D world is
not flat you need to use a `Camera` to look at it and navigate around it. Just
like when you are watching a movie and the scene pans to the left or right. This
same concept is applied when using a `Camera` object. The `Camera` object inherits
from `Node` and therefore supports most of the same `Action` objects. There are two types
of `Camera` objects: __perspective camera__ and __orthographic camera__.

The __perspective camera__ is used to see objects having a near to far effect. A
__perspective camera__ view might look like this:

![](3d-img/PerspectiveCamera.png)

As you can see with a __perspective camera__, objects in the _near_ are larger and
objects in the __far__ are smaller.

The __orthogonal camera__ is used to see objects as large distance. You can think
about it as converting a 3D world to a 2D representation. An __orthogonal camera__
view might look like this:

![](3d-img/OrthographicCamera.png)

As you can see with an __orthogonal camera__, objects are the same size regardless
of how far away from the `Camera` object they are. __Mini Maps__ in games are
commonly rendered with an __orthogonal camera__. Another example would be a top -
down view, perhaps in a dungeon style game.

### Camera Use
Don't worry! `Camera` objects may sound complicated but Cocos2d-x makes them easy.
When using 3D you don't have to do anything special to create a `Camera` object.
Each `Scene` automatically creates a default camera, based on the projection
properties of the `Director` object. If you need more than one camera, you can
use the following code to create one:

{% codetabs name="C++", type="cpp" -%}
auto s = Director::getInstance()->getWinSize();
auto camera = Camera::createPerspective(60, (GLfloat)s.width/s.height, 1, 1000);

// set parameters for camera
camera->setPosition3D(Vec3(0, 100, 100));
camera->lookAt(Vec3(0, 0, 0), Vec3(0, 1, 0));

addChild(camera); //add camera to the scene
{%- endcodetabs %}

### Creating orthogonal camera
The default `Camera` is a __perspective camera__. If you want to create an
__orthogonal camera__, it's easy to do by calling:

{% codetabs name="C++", type="cpp" -%}
Camera::createOrthographic();
{%- endcodetabs %}

Example:

{% codetabs name="C++", type="cpp" -%}
auto s = Director::getInstance()->getWinSize();
auto camera = Camera::createOrthographic(s.width, s.height, 1, 1000);
{%- endcodetabs %}

### Hiding objects from the camera
Sometimes you don't want to have all objects visible in a `Camera` view. Hiding
an object from one camera is very easy. Use __setCameraMask(CameraFlag)__ on the
`Node` and __setCameraFlag(CameraFlag)__ on the `Camera`. Example:

{% codetabs name="C++", type="cpp" -%}
//Camera
camera->setCameraFlag(CameraFlag::USER1);

//Node
node->setCameraMask(CameraFlag::USER1);
{%- endcodetabs %}

<a name="cubemap"></a>

## Cubemap Texture
A __cube map texture__ is a collection of six separate square textures that are
put onto the faces of an imaginary cube. Most often they are used to display
infinitely far away reflections on objects, similar to how __sky box__ displays
far away scenery in the background. This is what an expanded cube map might look
like:

![](3d-img/Cubemap.jpg)

In Cocos2d-x, you can create a __cube map texture__ in this way:

{% codetabs name="C++", type="cpp" -%}
// create a textureCube object with six texture assets
auto textureCube = TextureCube::create("skybox/left.jpg",  "skybox/right.jpg", "skybox/top.jpg", "skybox/bottom.jpg", "skybox/front.jpg", "skybox/back.jpg");

// set cube map texture parameters
Texture2D::TexParams tRepeatParams;
tRepeatParams.magFilter = GL_NEAREST;
tRepeatParams.minFilter = GL_NEAREST;
tRepeatParams.wrapS = GL_MIRRORED_REPEAT;
tRepeatParams.wrapT = GL_MIRRORED_REPEAT;
textureCube->setTexParameters(tRepeatParams);

// create and set our custom shader
auto shader = GLProgram::createWithFilenames("cube_map.vert", "cube_map.frag");
auto _state = GLProgramState::create(shader);

// bind cube map texture to uniform
state->setUniformTexture("u_cubeTex", textureCube);
{%- endcodetabs %}

<a name="skybox"></a>

## Skybox
`Skybox` is a wrapper around your entire scene that shows what the world looks
like beyond your geometry. You might use a `Skybox` to simulate infinite sky,
mountains and other phenomena.

![](3d-img/Skybox.png)

Creating a `Skybox`:

{% codetabs name="C++", type="cpp" -%}
// create a Skybox object
auto box = Skybox::create();

// set textureCube for Skybox
box->setTexture(_textureCube);

// attached to scene
_scene->addChild(box);
{%- endcodetabs %}

<a name="lighting"></a>
## Light
Light is really important for building mood and ambiance for a game. There are
currently 4 lighting techniques supported. You would use different lighting
techniques depending upon your needs. Each lighting effect achieves a different
result.

###Ambient Light
An `AmbientLight` object will apply light evenly for everything in the scene.
Think of lighting in an office environment. The lights are overhead and when you
look at objects around the office you see them in the same light. Example:

{% codetabs name="C++", type="cpp" -%}
auto light = AmbientLight::create (Color3B::RED);
addChild(light);
{%- endcodetabs %}

This produces:

![](3d-img/9_9_1.png)

###Directional Light
`DirectionalLight` is often used to simulate a light source such as
sunlight. When using `DirectionalLight` keep in mind that is has the same density
no matter where you are in relationship to it. Also think about being outside on
a sunny day with the sun beaming down on you. When you look directly at the sun,
it is an intense light even if you move a few steps in any direction. Example:

{% codetabs name="C++", type="cpp" -%}
auto light = DirectionLight::create(Vec3(-1.0f, -1.0f, 0.0f), Color3B::RED);
addChild(light);
{%- endcodetabs %}

This produces:

![](3d-img/9_9_2.png)

###Point Light
`PointLight` is often used to simulate the effect of light bulbs, lamps
or torches. The direction of a `PointLight` is from the lighted position to the
`PointLight`. Keep in mind that the density is different depending upon the
distance from the `PointLight`. What does this mean? If you are close to the
start of the `PointLight` it will be really strong. If you are towards the end
of the `PointLight` it will be dim. `PointLight` also becomes weaker the larger
the distance it is projected. Example:

{% codetabs name="C++", type="cpp" -%}
auto light = PointLight::create(Vec3(0.0f, 0.0f, 0.0f), Color3B::RED, 10000.0f);
addChild(light);
{%- endcodetabs %}

This produces:

![](3d-img/9_9_3.png)

###Spot Light
A `SpotLight` object is often used to simulate a flashlight. This means that it
is emitted in just one direction in the shape of a cone. Think about the power
going out in your house. You may need to take a flashlight down into your basement
to reset your circuits. The flashlight produces a cone shaped lighting pattern
and you can only see objects inside that cone pattern. Another example is in dark,
dungeon based games where your path is light by torches. You can only see the
limited cone shape that those torches emit. Example:

{% codetabs name="C++", type="cpp" -%}
auto spotLight = SpotLight::create(Vec3(-1.0f, -1.0f, 0.0f), Vec3(0.0f, 0.0f, 0.0f),
Color3B::RED, 0.0, 0.5, 10000.0f) ;
addChild(spotLight);
{%- endcodetabs %}

This produces:

![](3d-img/9_9_4.png)

###Light Masking
What do you use for lights in your kitchen or living room? Probably a few lamps?
Do you ever notice that perhaps you only use a lamp to light up a certain portion
of the room? You are essentially applying a __lighting mask__!

A __lighting mask__ is used on a `Node` to only apply a particular __lighting source__
to it. For example, if you had multiple lights in a `Scene`, a `Node` can only be
lighted by one of the lights instead of all three. You can use __setLightFlag(LightFlag)__
to control which `Node` objects are effected by the light. It is important to note
that all lighting sources are rendered in a single pass. Due to mobile platform
performance issues the use of multiple light sources is not recommended. The
default maximum is 1. If you want to open multiple light sources you must define
the following keys in __info.plist__:

{% codetabs name="Xml", type="xml" -%}
<key> cocos2d.x.3d.max_dir_light_in_shader </key>
<integer> 1 </integer>
<key> cocos2d.x.3d.max_point_light_in_shader </key>
<integer> 1 </integer>
<key> cocos2d.x.3d.max_spot_light_in_shader </key>
<integer> 1 </integer>
{%- endcodetabs %}

<a name="terrain"></a>

## Terrain
`Terrain` is an important component in 3D game. A texture is used to stand for the
height map. And up to 4 textures can be used to blend the details of the terrain,
grass, road, and so on.

### HeightMap
`HeightMap` objects are the core of the terrain. Different from the common image
the height map represents the height of vertices. It determines the terrain's
geometry shape.

### DetailMap
`DetailMap` objects are a list of textures determining the details of the terrain,
up to four textures can be used.

### AlphaMap
`AlphaMap` objects are an image whose data is the blend weights of __detail maps__.
The blending result is the final terrain's appearance.

### LOD policy
`Terrain` uses an optimization technique called __Level Of Detail__ or __LOD__.
This is a rendering technique that reduces the number of __verticies__ (or triangles)
that are rendered ,for an object,  as its distance from camera increases. Users
can set the distance to the `Camera` by calling the
__Terrain::setLODDistance(float lod1, float lod2, float lod3)__ method.

Neighboring chunks of `Terrain` objects, which have different __LOD__ may cause
 the __crack__ artifacts. `Terrain` provide two functions to avoid them:

{% codetabs name="C++", type="cpp" -%}
Terrain::CrackFixedType::SKIRT

Terrain::CrackFixedType::INCREASE_LOWER
{%- endcodetabs %}

__Terrain::CrackFixedType::SKIRT__ will generate four, skirt-like meshes at each
edge of the chunk.

__Terrain::CrackFixedType::INCREASE_LOWER__ will dynamically adjust each chunks
__indices__ to seamlessly connect them.

### How to create a terrain
Creating a `Terrain` takes a few steps. Example:

The following code snippet is creating a player and place it on the terrain:

{% codetabs name="C++", type="cpp" -%}
auto player = Sprite3D::create("chapter9/orc.c3b");
player->setScale(0.08);
player->setPositionY(terrain->getHeight(player->getPositionX(),player->getPositionZ()));
{%- endcodetabs %}

![](3d-img/9_10.png)

* create all `DetailMap` objects (up to four), you need pass the `DetailMap`
objects to the __Terrain::DetailMap__ struct:

{% codetabs name="C++", type="cpp" -%}
Terrain::DetailMap r("dirt.dds");
Terrain::DetailMap g("grass.dds");
Terrain::DetailMap b("road.dds");
Terrain::DetailMap a("greenSkin.jpg");
{%- endcodetabs %}

* to create a `TerrainData` variable with __detail maps__, you need to specify
the terrain's __height map__ file path and __alpha map__ file path:

{% codetabs name="C++", type="cpp" -%}
Terrain::TerrainData data("chapter9/heightmap16.jpg","TerrainTest/alphamap.png", r, g, b, a);
{%- endcodetabs %}

* pass the `TerrainData` object to __Terrain::create__, the last parameter determines
the LOD policy (as talked about above). Example:

{% codetabs name="C++", type="cpp" -%}
_terrain = Terrain::create(data, Terrain::CrackFixedType::SKIRT);
{%- endcodetabs %}

* If you set a `Terrain` objects __camera mask__ and add it to a `Node` or a
`Scene`, be careful. When `Terrain` is added into a `Node` or a `Scene`, you can
not use __transform(translate, scale)__ on it anymore. If you do this after calling
__addChild()__, some of the terrain's methods may calculate wrong results.

### Get Terrain Height
Use the method __Terrain::getHeight(float x, float z, Vec3 * normal= nullptr)__ to
get the specified position's height. This method is very useful when you want to
put a `Sprite3D` object or any `Node` on the terrain's surface.

### Ray-Terrain intersection test
A __Ray-Terrain__ intersection test will calculate the intersection point by giving
a specified position.

__Terrain::CrackFixedType::SKIRT__ will generate four skirt-like meshes at each
chunks edge.

__Terrain::CrackFixedType::INCREASE_LOWER__ will dynamically adjust each chunks
index to seamlessly connect them.

<a name="tools"></a>

## 3D Software Packages

### 3D Editors
3D editors are collections of tools that you use to build your 3D graphics. There
are both commercial and free tools available. These are the most popular editors:

* [Blender (Free)](http://www.blender.org/)
* [3DS Max](http://www.autodesk.com/products/3ds-max/overview)
* [Cinema4D](http://www.maxon.net/products/)
* [Maya](http://www.autodesk.com/products/maya/overview)

Most 3D editors usually save files in a common collection of formats for easy
use within other editors as well as a standard way for game engines to import
your files for use.

###Cocos2d-x Provided Tools
Cocos2d-x provides tools to help with converting your 3D models to formats that
Cocos2d-x uses to provide access to all aspects of your 3D files.

####fbx-conv command-line tool
__fbx-conv__ allows the conversion of an FBX file into the Cocos2d-x proprietary
formats. FBX is the most popular 3D file format and is being supported by all
the major editors. __fbx-conv__ exports to __.c3b__ by default. It is simple to use
with just a few parameters:

{% codetabs name="shell", type="sh" -%}
fbx-conv [-a|-b|-t] FBXFile
{%- endcodetabs %}

The possible switches are:

* -?: show help
* -a: export both text and binary format
* -b: export binary format
* -t: export text format

Example:

{% codetabs name="shell", type="sh" -%}
fbx-conv -a boss.FBX
{%- endcodetabs %}

There are a few things to note about __fbx-conv__:
* The model needs to have a material that contains at least one texture
* it only supports skeletal animation.
* it only supports one skeleton object no multiple skeleton support yet.
* You can create a 3d scene by exporting multiple static model
* The maximum amount of vertices or indices a mesh is 32767

## 3D File Formats
Cocos2d-x currently supports two 3d file formats:

* [Wavefront Object](http://en.wikipedia.org/wiki/Wavefront_.obj_file) files:
__.obj__ files
* Cocos2d-x 3d ad-hoc format:__c3t__, __c3b__ files.

The __Wavefront__ file format is supported because it has been widely adopted by
3D editors and it is extremely easy to parse. It is, however, limited and
doesn't support advanced features like animations.

On the other hand, __c3t__ and __c3b__ are Cocos2d-x proprietary file formats that
were created to allow animations, materials and other advanced 3d features.
The suffix __t__ means __text__, while the suffix __b__ means __binary__. Developers
must use __c3b__ for production because it is more efficient. In case you want to
debug the file and track its changes in Git or any other version control system,
you should __c3t__ instead. Also, `Animation3D` objects can be created with __c3b__
or __c3t__ files as it is not possible to animate __obj__ files.

<a name="advanced"></a>

##Advanced Topics

###BillBoard
You may not have heard of a `BillBoard` before. No, I'm not talking about an
advertisement on the side of a highway. Rather, `Billboard` is a special `Sprite`
that always faces the `Camera`. As you rotate the `Camera`, `Billboard` objects
also rotate. Using a`BillBoard` is a very common rendering technique. Take for
example a downhill skiing game. Any trees, rocks or other objects that are in
the way of the skier are `Billboard` objects.

This is how `Camera` and `Billboard` objects relate to each other.

![](3d-img/BillBoard.png)

`Billboard` objects are easy to create. `BillBoard` is derived from `Sprite`, so
it supports most of the features as a `Sprite` object. We can create one using the
following create method:

{% codetabs name="C++", type="cpp" -%}
auto billboard = BillBoard::create("Blue_Front1.png", BillBoard::Mode::VIEW_POINT_ORIENTED);
{%- endcodetabs %}

You can also create a `Billboard` object for the camera XOY plane (like the plane
  of a floor) by changing the `BillBoard` objects mode:

{% codetabs name="C++", type="cpp" -%}
auto billboard = BillBoard::create("Blue_Front1.png", BillBoard::Mode::VIEW_PLANE_ORIENTED);
{%- endcodetabs %}

These _create_ methods look a little different since an additional parameter of
__BillBoard::Mode__ is passed in. There are two __BillBoard::Mode__ types,
__VIEW_POINT_ORIENTED__ and __VIEW_PLANE_ORIENTED__.

__VIEW_POINT_ORIENTED__ is where the `BillBoard` object is oriented to the
`Camera`. Example:

![](3d-img/9_8_1.png)

 __VIEW_PLANE_ORIENTED__ is where the `BillBoard` is oriented towards the XOY plane
 of the `Camera`. Example:

![](3d-img/9_8_2.png)

You can also set properties for a `BillBoard` just like with any other `Node`.
These include, but are not limited to: __scale__, __position__, __rotation__.
Examples:

{% codetabs name="C++", type="cpp" -%}
billboard->setScale(0.5f);
billboard->setPosition3D(Vec3(0.0f, 0.0f, 0.0f));
billboard->setBlendFunc(BlendFunc::ALPHA_NON_PREMULTIPLIED);
addChild(billboard);
{%- endcodetabs %}

###ParticleSystem3D
In Chapter 7, you learned about 2D particles and how to use them. When you use 3D
you might also want to use a 3D particle system for rich, advanced effects. Many
of the same concepts apply for a 3D particle system as they did with a 2D particle
system. Cocos2d-x currently supports __Particle Universe__ (http://www.fxpression.com/)
for particle system construction. __Particle Universe__ provides a special particle
editor that allows you to quickly and easily set up a variety of effects, such as
explosions, fire, blood and other special effects. This editor uses a __pu__ file
extension when saving or exporting.

When you are happy with your particle and ready to use it in code, exporting to
its built-in format of __pu__ is enough! Cocos2d-x supports this format directly.
Also, as `ParticleSystem3D` is derived from `Node`, it supports most of the
features that `Node` supports. `PUParticleSystem3D` is an object type specifically
for dealing with __Particle Universe__ particles. `PUParticleSystem3D` offers two
ways for creating particles.

The first way is to build a particle by passing in a __Particle Universe__ file
and its corresponding __material file__. Remember from Chapter 7 that a
__material file__ is what describes the particle. This is required. Example:

{% codetabs name="C++", type="cpp" -%}
auto ps = PUParticleSystem3D::create("lineStreak.pu", "pu_mediapack_01.material");
ps->startParticleSystem();
this->addChild(ps);
{%- endcodetabs %}

The second way is to build the particle system only by passing a __particle universe__
file. When you create a particle this way, besides loading the particle, all
__material files__ in the same folder as the particle file will automatically be
loaded. Here is an example:

{% codetabs name="C++", type="cpp" -%}
auto ps = PUParticleSystem3D::create("electricBeamSystem.pu");
ps->startParticleSystem();

this->addChild(ps);
{%- endcodetabs %}

  __Note:__ using this method will result in an increase in loading times and
consumes more memory since everything will be loaded. If you know what __material__
you want to use and don't need to load everything, using the first method would
be preferred.

In these images below, on the left is the particle in __particle universe__, while
on the right is the effect running in Cocos2d-x:

![](3d-img/particle1.png) ![](3d-img/particle2.png)

Once you have your particle, you can interact with it it fairly obvious ways. You
can interact with with the __particle system__ as a whole, starting, stopping,
pausing, resuming and obtaining the total number of particles:

{% codetabs name="C++", type="cpp" -%}
virtual void startParticleSystem() override;
virtual void stopParticleSystem() override;
virtual void pauseParticleSystem() override;
virtual void resumeParticleSystem() override;
virtual int getAliveParticleCount() const override;
{%- endcodetabs %}

As `PUParticleSystem3D` is derived from `Node` you can run `Action` and `Sequence`
objects on your particles! Example:

{% codetabs name="C++", type="cpp" -%}
auto ps = PUParticleSystem3D::create("blackHole.pu", "pu_mediapack_01.material");
ps->setPosition(-25.0f, 0.0f);

auto moveby = MoveBy::create(2.0f, Vec2(50.0f, 0.0f));
auto moveby1 = MoveBy::create(2.0f, Vec2(-50.0f, 0.0f));

ps->runAction(RepeatForever::create(Sequence::create(moveby, moveby1, nullptr)));
ps->startParticleSystem();
{%- endcodetabs %}

Combining `Action` and `Sequence` objects could produce an interesting black hole
effect:

![](3d-img/particle3.png)

Just like with other 3D objects you can also combine 3D objects using `AttachNode`.
This allows for creating rich models. Example:

{% codetabs name="C++", type="cpp" -%}
auto sprite3d = Sprite3D::create("orc.c3b");
sprite3d->setPosition3D(Vec3(0.0f, 0.0f, 0.0f));
sprite3d->setRotation3D(Vec3(0.0f, 180.0f, 0.0f));

auto animation = Animation3D::create("orc.c3b");
if (animation)
{
    auto animate = Animate3D::create(animation);
    sprite3d->runAction(RepeatForever::create(animate));
}

auto handler = PUParticleSystem3D::create("lightningBolt.pu");
handler->startParticleSystem();
sprite3d->getAttachNode("Bip001 L Hand")->addChild(handler);

this->addChild(sprite3d);
{%- endcodetabs %}

![](3d-img/particle4.png)


<!---
BillBoard provides several create methods, as follows:
```
static BillBoard * create (Mode mode = Mode :: VIEW_POINT_ORIENTED);
static BillBoard * create (const std :: string & filename, Mode mode = Mode :: VIEW_POINT_ORIENTED);
static BillBoard * create (const std :: string & filename, const Rect & rect, Mode mode = Mode :: VIEW_POINT_ORIENTED);
static BillBoard * createWithTexture (Texture2D * texture, Mode mode = Mode :: VIEW_POINT_ORIENTED);
Mode is BillBoard facing mode, currently supports two faces, one is facing the camera's origin (the default mode), and the other one is facing the camera XOY plane, as follows:

enum class Mode
{
VIEW_POINT_ORIENTED, // orient to the camera
VIEW_PLANE_ORIENTED // orient to the XOY plane of camera
};
```
Cocos2d-x from the BillBoard increase in the Renderer class to introduce a transparent
render queue, in order to ensure proper rendering of transparent objects, the queue
after the other rendering render queue, and the queue at the specified Order values ​​
are sorted in descending . In BillBoard's rendering, BillBoard passed to clear the
queue itself -Z value in the camera coordinate system (farther away from the camera
body The higher the value) size, and then be able to achieve the correct rendering
of BillBoard's. If you need a custom rendering of transparent objects can consider
using the queue, the queue to add way as follows:

_quadCommand.init (_zDepthInView, _texture-> getName (), getGLProgramState (), _blendFunc, & _quad, 1, _billboardTransform);
renderer-> addCommandToTransparentQueue (& _ quadCommand);
BillBoard more details see the use of the methods and examples of BillBoardTest
with cpptests


### Coordinate transformation
`Camera` provide helpers to transform coordinates from screen space to world
space. Example:
```cpp
void unproject (const Size & viewport, Vec3 * src, Vec3 * dst) const;
```
Here viewport is _viewport size_, use `src` as screen coordinates, the z axis of
the `src` indicates clipping plane distance information, -1 means the near
clipping plane, 1 means far clipping plane. The `dst` parameter will return
world space coordinates.


 ## Ray
`Ray` is super useful in 3D game. You can use `Ray` to achieve things like picking up
an object in 3D or detect collision in 3D.

Illustration:

![](3d-img/Ray.png)

### Creating a Ray

You need two vectors to create a `Ray`, one is the origin, the other is the
direction. Example:
```cpp
Ray ray (Vec3 (0,0,0), Vec3 (0,0,1));
```
This will create a `Ray` originated from (0,0,0) in the direction of the positive
Z axis.

With this `Ray`, you can call the function with space intersects AABB box or any
box OBB collision, the code is as follows:
```cpp
Ray ray (Vec3 (0,0,0), Vec3 (0,0,1));
AABB aabb (Vec (-1, -1, -1), Vec (1,1,1));
if (ray .intersects (aabb))
{
	// ray intersects with AABB
}
else
{
	// ray does not intersect with the AABB
}
```

## AABB
`AABB` mean axis aligned bounding box, a 3D AABB is a simple six-sided, each side
is parallel to a coordinate plane. It would look like this:

![](3d-img/AABB.png)

AABB properties:

Two vertices is particularly important: Pmin = [Xmin Ymin Zmin], Pmax = [Xmax Ymax Zmax].
Other points on the box are met

Xmin <= X <= Xmax Ymin <= Y <= Ymax Zmin <= Z <= Zmax

### AABB use
`AABB` is usually used in the game to do some non-precision collision detection,
AABB concept without direction, only Pmin and Pmax points, you can build an AABB
box through these two points, the code is as follows:
```cpp
AABB aabb (Vec (-1, -1, -1), Vec (1,1,1));
```
If you want to detect whether two AABB collision can call
bool intersects (const AABB & aabb) const function, for example, we create two
AABB bounding box collision detection and then the code is as follows:

AABB a (Vec (-1, -1, -1), Vec (1,1,1)); AABB b (Vec (0,0,0), Vec (2,2,2));
if (a .intersect (b)) {// collision} else {// not collide}

AABB collision detection is done with two points Pmin and Pmax compare AABB
collision detection so fast.

In addition, citing several AABB commonly used functions, as follows:
```cpp
void getCorners (Vec3 * dst) const; // get the world coordinate AABB 8 vertices

bool containPoint (const Vec3 & point) const; // detect whether a point is
contained in a box inside the AABB

void merge (const AABB & box); // merge two AABB box

void updateMinMax (const Vec3 * point, ssize_t num); // update Pmin or Pmax

void transform (const Mat4 & mat); // transform operation on the AABB Box
```
## OBB
`OBB` (Oriented Bounding Box, there is the bounding box) is a close rectangular
object, but the object of the box can be rotated. OBB than AABB bounding sphere
and is closer to the object, can significantly reduce the number of the surrounded
body. It would look like this:

![](3d-img/OBB.png)

### OBB nature

OOBB bounding boxes are directional, we use three mutually perpendicular vectors
to describe the OBB bounding box of the local coordinate system, these three
vectors are _xAxis, _yAxis, _zAxis, with _extents vector to describe the OBB
bounding box in each on the axial length.

### OBB use

You can AABB structure OBB, the code is as follows:
```cpp
AABB aabb (Vec (-1, -1, -1), Vec (1,1,1)); OBB obb ​​(aabb);
```
Or you can directly constructed by eight points

Vec3 a [] = {Vec3 (0,0,0), Vec3 (0,1,0), Vec3 (1,1,0), Vec3 (1,0,0), Vec3 (1,0,1) , Vec3 (1,1,1), Vec3 (0,1,1), Vec3 (0,0,1)}; OBB obb ​​(a, 8);

If you want to detect whether two OBB collision can call
bool intersects (const OBB & aabb) const function,
for example, then we create two OBB collision detection code below

AABB aabbSrc (Vec (-1, -1, -1), Vec (1,1,1)); AABB aabbDes (Vec (0,0,0), Vec (2,2,2)); OBB obbSrc (aabbSrc); OBB obbDes (aabbDes); if (obbSrc.intersect (obbDes)) {// collision} else {// not collide}

In addition, citing several OBB commonly used functions, as follows:

void getCorners (Vec3 * dst) const; // get the world coordinate OBB 8 vertices

bool containPoint (const Vec3 & point) const; // detect whether a point is
contained in a box inside OBB

void transform (const Mat4 & mat); // transform on OBB box

## Mesh
A `Mesh` is an object that can be rendered and includes the _index cache_,
_GLProgram state set_, _texture_, _bone_, _blending equations_, _AABB_ and any
other data you might need. `Mesh` objects are usually built by an internal class
and does not require users to set up and use by the time `Sprite3D` created. For
advanced users and sometimes may not need to import by way of an external model,
but directly to build the model (such as a plane, cube, sphere, etc.) through the
vertex index data for rendering. This time we need to build the appropriate data
independently Mesh and customize rendering Command for custom drawing, it is
necessary to use a separate pair Mesh explained.

### Building a Mesh
Mesh by more create methods can create the Mesh, for example, by the most common
vertex array, normals, texture coordinates, and index the array passed to create
a quadrilateral:
```cpp
std::vector<float> positions;
std::vector<float> normals;
std::vector<float> texs;
Mesh::IndexArray indices;

positions.push_back(-5.0f);positions.push_back(-5.0f);positions.push_back(0.0f);
positions.push_back(5.0f);positions.push_back(-5.0f);positions.push_back(0.0f);
positions.push_back(5.0f);positions.push_back(5.0f);positions.push_back(0.0f);
positions.push_back(-5.0f);positions.push_back(5.0f);positions.push_back(0.0f);

texs.push_back(0.0f);texs.push_back(0.0f);
texs.push_back(1.0f);texs.push_back(0.0f);
texs.push_back(1.0f);texs.push_back(1.0f);
texs.push_back(0.0f);texs.push_back(1.0f);

indices.push_back(0);
indices.push_back(1);
indices.push_back(2);
indices.push_back(0);
indices.push_back(2);
indices.push_back(3);

auto mesh = Mesh::create(positions, normals, texs, indices);
mesh->setTexture("quad.png");
```
How to render the construct Mesh? When all the information is rendered after we
finished building Mesh already have, but also need the appropriate data into the
rendering pipeline to render, so you can consider building a custom class derived
from Node, overloading the Draw method, and building a MeshCommand in the Draw
method and pass relevant data into the Mesh render queue, eventually rendering.
For example custom class Draw method can add the following code:
```cpp
auto programstate = mesh->getGLProgramState();
auto& meshCommand = mesh->getMeshCommand();
GLuint textureID = mesh->getTexture() ? mesh->getTexture()->getName() : 0;
meshCommand.init(_globalZOrder
, textureID
, programstate
, _blend
, mesh->getVertexBuffer()
, mesh->getIndexBuffer()
, mesh->getPrimitiveType()
, mesh->getIndexFormat()
, mesh->getIndexCount()
, transform);
renderer->addCommand(&meshCommand);
```
The results:

![](3d-img/quad.png)
--->
